"""
Î¶¨Ïä§ÌÅ¨ Î™®ÎãàÌÑ∞ÎßÅ Î∞±Í∑∏ÎùºÏö¥Îìú ÏõåÏª§

Ï£ºÍ∏∞Ï†ÅÏúºÎ°ú Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ Î¶¨Ïä§ÌÅ¨Î•º Î™®ÎãàÌÑ∞ÎßÅÌïòÍ≥† ÏûÑÍ≥ÑÍ∞í Ï¥àÍ≥º Ïãú ÏïåÎ¶ºÏùÑ Ï†ÑÏÜ°Ìï©ÎãàÎã§.
"""

import asyncio
import logging
from datetime import datetime, time
from typing import Dict, List, Optional, Set

from app.core.config import settings
from app.services.telegram_service import TelegramService
from app.services.binance_client import BinanceClient
from app.services.okx_client import OKXClient
from app.models.api_key import ApiKey
from app.database.session import get_db
from sqlalchemy.orm import Session

logger = logging.getLogger(__name__)


class RiskMonitorConfig:
    """Î¶¨Ïä§ÌÅ¨ Î™®ÎãàÌÑ∞ÎßÅ ÏÑ§Ï†ï"""

    # VaR ÏûÑÍ≥ÑÍ∞í (Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ Í∞ÄÏπò ÎåÄÎπÑ %)
    VAR_WARNING_THRESHOLD = 7.5
    VAR_DANGER_THRESHOLD = 10.0

    # Ï≤≠ÏÇ∞Í∞Ä Í∑ºÏ†ë Í≤ΩÍ≥† ÏûÑÍ≥ÑÍ∞í (%)
    LIQUIDATION_WARNING_THRESHOLD = 15.0
    LIQUIDATION_DANGER_THRESHOLD = 10.0
    LIQUIDATION_CRITICAL_THRESHOLD = 5.0

    # Ìè¨ÏßÄÏÖò ÏßëÏ§ëÎèÑ ÏûÑÍ≥ÑÍ∞í
    SINGLE_POSITION_WARNING = 30.0  # Îã®Ïùº Ìè¨ÏßÄÏÖòÏù¥ 30% Ï¥àÍ≥º
    SINGLE_POSITION_DANGER = 40.0   # Îã®Ïùº Ìè¨ÏßÄÏÖòÏù¥ 40% Ï¥àÍ≥º
    TOP3_CONCENTRATION_WARNING = 60.0  # ÏÉÅÏúÑ 3Í∞ú Ìè¨ÏßÄÏÖòÏù¥ 60% Ï¥àÍ≥º
    TOP3_CONCENTRATION_DANGER = 75.0   # ÏÉÅÏúÑ 3Í∞ú Ìè¨ÏßÄÏÖòÏù¥ 75% Ï¥àÍ≥º

    # ÏµúÎåÄ ÎÇôÌè≠ ÏûÑÍ≥ÑÍ∞í
    MAX_DRAWDOWN_WARNING = 15.0
    MAX_DRAWDOWN_DANGER = 20.0

    # Î™®ÎãàÌÑ∞ÎßÅ Í∞ÑÍ≤© (Ï¥à)
    MONITORING_INTERVAL = 60  # 1Î∂ÑÎßàÎã§ Ï≤¥ÌÅ¨

    # ÏùºÏùº Î¶¨Ìè¨Ìä∏ Ï†ÑÏÜ° ÏãúÍ∞Ñ (UTC)
    DAILY_REPORT_TIME = time(23, 0)  # UTC 23:00 = KST 08:00 (Îã§ÏùåÎÇ† ÏïÑÏπ®)

    # Ï§ëÎ≥µ ÏïåÎ¶º Î∞©ÏßÄ (Í∞ôÏùÄ Ïù¥ÏäàÎäî NÎ∂ÑÎßàÎã§Îßå ÏïåÎ¶º)
    ALERT_COOLDOWN_MINUTES = 30


class RiskMonitor:
    """Î¶¨Ïä§ÌÅ¨ Î™®ÎãàÌÑ∞ÎßÅ ÏÑúÎπÑÏä§"""

    def __init__(self):
        self.telegram = TelegramService()
        self.config = RiskMonitorConfig()

        # ÎßàÏßÄÎßâ ÏïåÎ¶º ÏãúÍ∞Ñ Ï∂îÏ†Å (Ï§ëÎ≥µ Î∞©ÏßÄ)
        self.last_alerts: Dict[str, datetime] = {}

        # ÏùºÏùº Î¶¨Ìè¨Ìä∏ Ï†ÑÏÜ° Ï∂îÏ†Å
        self.last_daily_report_date: Optional[datetime] = None

        # ÌôúÏÑ± ÏÉÅÌÉú
        self.is_running = False

    async def start(self):
        """Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûë"""
        self.is_running = True
        logger.info("üöÄ Risk monitoring service started")

        while self.is_running:
            try:
                # Î™®Îì† ÌôúÏÑ± Í≥ÑÏ†ï Î™®ÎãàÌÑ∞ÎßÅ
                await self.monitor_all_accounts()

                # ÏùºÏùº Î¶¨Ìè¨Ìä∏ Ï≤¥ÌÅ¨
                await self.check_daily_report()

            except Exception as e:
                logger.error(f"Risk monitoring error: {e}", exc_info=True)

            # Îã§Ïùå Ï≤¥ÌÅ¨ÍπåÏßÄ ÎåÄÍ∏∞
            await asyncio.sleep(self.config.MONITORING_INTERVAL)

    async def stop(self):
        """Î™®ÎãàÌÑ∞ÎßÅ Ï§ëÏßÄ"""
        self.is_running = False
        logger.info("üõë Risk monitoring service stopped")

    async def monitor_all_accounts(self):
        """Î™®Îì† ÌôúÏÑ± Í≥ÑÏ†ï Î™®ÎãàÌÑ∞ÎßÅ"""
        db: Session = next(get_db())

        try:
            # Î™®Îì† ÌôúÏÑ± API ÌÇ§ Ï°∞Ìöå
            active_keys = db.query(ApiKey).filter(
                ApiKey.is_active == True
            ).all()

            for api_key in active_keys:
                try:
                    await self.monitor_account(api_key, db)
                except Exception as e:
                    logger.error(f"Error monitoring account {api_key.id}: {e}")

        finally:
            db.close()

    async def monitor_account(self, api_key: ApiKey, db: Session):
        """Í∞úÎ≥Ñ Í≥ÑÏ†ï Î™®ÎãàÌÑ∞ÎßÅ"""

        # Í±∞ÎûòÏÜå ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏÉùÏÑ±
        if api_key.exchange == "binance":
            client = BinanceClient(
                api_key=api_key.api_key,
                api_secret=api_key.api_secret,
                testnet=api_key.testnet
            )
        elif api_key.exchange == "okx":
            client = OKXClient(
                api_key=api_key.api_key,
                api_secret=api_key.api_secret,
                passphrase=api_key.passphrase,
                testnet=api_key.testnet
            )
        else:
            logger.warning(f"Unsupported exchange: {api_key.exchange}")
            return

        # Í≥ÑÏ†ï Ï†ïÎ≥¥ Ï°∞Ìöå
        try:
            balance_info = await client.get_account_balance()
            positions = await client.get_positions()

            # ÌÖîÎ†àÍ∑∏Îû® Ï±ÑÌåÖ ID (UserÏôÄ Ïó∞Í≤∞ÎêòÏñ¥Ïïº Ìï®, Ïó¨Í∏∞ÏÑúÎäî Í∞ÑÎã®Ìûà Íµ¨ÌòÑ)
            # Ïã§Ï†úÎ°úÎäî User Î™®Îç∏Ïóê telegram_chat_id ÌïÑÎìú Ï∂îÍ∞Ä ÌïÑÏöî
            chat_id = getattr(api_key.user, 'telegram_chat_id', None)

            if not chat_id:
                # ÌÖîÎ†àÍ∑∏Îû® ÎØ∏ÏÑ§Ï†ï Ïãú Ïä§ÌÇµ
                return

            # Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ Í∞ÄÏπò
            total_balance = float(balance_info.get('totalWalletBalance', 0))

            # ÌôúÏÑ± Ìè¨ÏßÄÏÖò ÌïÑÌÑ∞ÎßÅ
            active_positions = [p for p in positions if float(p.get('positionAmt', 0)) != 0]

            if not active_positions:
                # Ìè¨ÏßÄÏÖò ÏóÜÏúºÎ©¥ Ïä§ÌÇµ
                return

            # 1. VaR Ï≤¥ÌÅ¨
            await self.check_var(
                api_key=api_key,
                chat_id=chat_id,
                total_balance=total_balance,
                positions=active_positions
            )

            # 2. Ï≤≠ÏÇ∞Í∞Ä Í∑ºÏ†ë Ï≤¥ÌÅ¨
            await self.check_liquidation_proximity(
                api_key=api_key,
                chat_id=chat_id,
                positions=active_positions
            )

            # 3. Ìè¨ÏßÄÏÖò ÏßëÏ§ëÎèÑ Ï≤¥ÌÅ¨
            await self.check_position_concentration(
                api_key=api_key,
                chat_id=chat_id,
                total_balance=total_balance,
                positions=active_positions
            )

        except Exception as e:
            logger.error(f"Error monitoring account {api_key.id}: {e}")

    async def check_var(
        self,
        api_key: ApiKey,
        chat_id: str,
        total_balance: float,
        positions: List[Dict]
    ):
        """VaR (Value at Risk) Ï≤¥ÌÅ¨"""

        # Í∞ÑÎã®Ìïú VaR Ï∂îÏ†ï: Ï¥ù ÎÖ∏Ï∂úÏùò 5% (95% Ïã†Î¢∞ÏàòÏ§Ä)
        total_exposure = sum(
            abs(float(p.get('notional', 0)))
            for p in positions
        )

        # VaR = Ï¥ù ÎÖ∏Ï∂ú * 5% (Í∞ÄÏ†ï: 95% Ïã†Î¢∞ÏàòÏ§ÄÏóêÏÑú ÏùºÏùº Î≥ÄÎèôÏÑ± 5%)
        var_amount = total_exposure * 0.05
        var_percentage = (var_amount / total_balance * 100) if total_balance > 0 else 0

        # ÏûÑÍ≥ÑÍ∞í Ï≤¥ÌÅ¨
        alert_key = f"{api_key.id}_var"

        if var_percentage > self.config.VAR_DANGER_THRESHOLD:
            if self._should_send_alert(alert_key):
                self.telegram.send_var_alert(
                    chat_id=chat_id,
                    current_var_amount=var_amount,
                    current_var_percentage=var_percentage,
                    threshold_percentage=self.config.VAR_DANGER_THRESHOLD,
                    confidence_level=95
                )
                self._mark_alert_sent(alert_key)
                logger.warning(
                    f"VaR alert sent for account {api_key.id}: "
                    f"{var_percentage:.2f}% (threshold: {self.config.VAR_DANGER_THRESHOLD}%)"
                )

        elif var_percentage > self.config.VAR_WARNING_THRESHOLD:
            if self._should_send_alert(alert_key):
                self.telegram.send_var_alert(
                    chat_id=chat_id,
                    current_var_amount=var_amount,
                    current_var_percentage=var_percentage,
                    threshold_percentage=self.config.VAR_WARNING_THRESHOLD,
                    confidence_level=95
                )
                self._mark_alert_sent(alert_key)
                logger.info(
                    f"VaR warning sent for account {api_key.id}: "
                    f"{var_percentage:.2f}% (threshold: {self.config.VAR_WARNING_THRESHOLD}%)"
                )

    async def check_liquidation_proximity(
        self,
        api_key: ApiKey,
        chat_id: str,
        positions: List[Dict]
    ):
        """Ï≤≠ÏÇ∞Í∞Ä Í∑ºÏ†ë Ï≤¥ÌÅ¨"""

        for position in positions:
            try:
                symbol = position.get('symbol')
                side = 'long' if float(position.get('positionAmt', 0)) > 0 else 'short'
                entry_price = float(position.get('entryPrice', 0))
                mark_price = float(position.get('markPrice', 0))
                liquidation_price = float(position.get('liquidationPrice', 0))
                leverage = int(position.get('leverage', 1))

                if liquidation_price == 0:
                    continue

                # Ï≤≠ÏÇ∞Í∞ÄÍπåÏßÄ Í±∞Î¶¨ Í≥ÑÏÇ∞
                if side == 'long':
                    distance = ((mark_price - liquidation_price) / mark_price * 100)
                else:
                    distance = ((liquidation_price - mark_price) / mark_price * 100)

                # ÏûÑÍ≥ÑÍ∞í Ï≤¥ÌÅ¨
                alert_key = f"{api_key.id}_liquidation_{symbol}"

                if distance <= self.config.LIQUIDATION_CRITICAL_THRESHOLD:
                    # Ìï≠ÏÉÅ ÏïåÎ¶º (Îß§Ïö∞ ÏúÑÌóò)
                    self.telegram.send_liquidation_warning(
                        chat_id=chat_id,
                        symbol=symbol,
                        side=side,
                        entry_price=entry_price,
                        current_price=mark_price,
                        liquidation_price=liquidation_price,
                        distance_percent=distance,
                        leverage=leverage
                    )
                    logger.critical(
                        f"CRITICAL liquidation warning for {symbol}: "
                        f"{distance:.2f}% from liquidation"
                    )

                elif distance <= self.config.LIQUIDATION_DANGER_THRESHOLD:
                    if self._should_send_alert(alert_key):
                        self.telegram.send_liquidation_warning(
                            chat_id=chat_id,
                            symbol=symbol,
                            side=side,
                            entry_price=entry_price,
                            current_price=mark_price,
                            liquidation_price=liquidation_price,
                            distance_percent=distance,
                            leverage=leverage
                        )
                        self._mark_alert_sent(alert_key)
                        logger.error(
                            f"Liquidation danger for {symbol}: "
                            f"{distance:.2f}% from liquidation"
                        )

                elif distance <= self.config.LIQUIDATION_WARNING_THRESHOLD:
                    if self._should_send_alert(alert_key):
                        self.telegram.send_liquidation_warning(
                            chat_id=chat_id,
                            symbol=symbol,
                            side=side,
                            entry_price=entry_price,
                            current_price=mark_price,
                            liquidation_price=liquidation_price,
                            distance_percent=distance,
                            leverage=leverage
                        )
                        self._mark_alert_sent(alert_key)
                        logger.warning(
                            f"Liquidation warning for {symbol}: "
                            f"{distance:.2f}% from liquidation"
                        )

            except Exception as e:
                logger.error(f"Error checking liquidation for {position.get('symbol')}: {e}")

    async def check_position_concentration(
        self,
        api_key: ApiKey,
        chat_id: str,
        total_balance: float,
        positions: List[Dict]
    ):
        """Ìè¨ÏßÄÏÖò ÏßëÏ§ëÎèÑ Ï≤¥ÌÅ¨"""

        # Ìè¨ÏßÄÏÖò ÌÅ¨Í∏∞ Í≥ÑÏÇ∞
        position_sizes = []
        for position in positions:
            try:
                symbol = position.get('symbol')
                notional = abs(float(position.get('notional', 0)))
                percentage = (notional / total_balance * 100) if total_balance > 0 else 0
                position_sizes.append((symbol, percentage))
            except Exception as e:
                logger.error(f"Error calculating position size: {e}")

        if not position_sizes:
            return

        # ÌÅ¨Í∏∞Î≥Ñ Ï†ïÎ†¨
        position_sizes.sort(key=lambda x: x[1], reverse=True)

        # ÏµúÎåÄ Ìè¨ÏßÄÏÖò
        largest_symbol, largest_pct = position_sizes[0]

        # ÏÉÅÏúÑ 3Í∞ú ÏßëÏ§ëÎèÑ
        top3_pct = sum(pct for _, pct in position_sizes[:3])

        # HHI (Herfindahl-Hirschman Index) Í≥ÑÏÇ∞
        hhi = sum(pct ** 2 for _, pct in position_sizes)

        # ÏûÑÍ≥ÑÍ∞í Ï≤¥ÌÅ¨
        alert_key = f"{api_key.id}_concentration"

        danger_triggered = False
        warning_triggered = False

        if largest_pct > self.config.SINGLE_POSITION_DANGER or top3_pct > self.config.TOP3_CONCENTRATION_DANGER:
            danger_triggered = True
        elif largest_pct > self.config.SINGLE_POSITION_WARNING or top3_pct > self.config.TOP3_CONCENTRATION_WARNING:
            warning_triggered = True

        if danger_triggered or warning_triggered:
            if self._should_send_alert(alert_key):
                self.telegram.send_concentration_warning(
                    chat_id=chat_id,
                    largest_position_symbol=largest_symbol,
                    largest_position_pct=largest_pct,
                    top3_concentration_pct=top3_pct,
                    hhi=hhi,
                    total_positions=len(positions)
                )
                self._mark_alert_sent(alert_key)

                log_level = logger.error if danger_triggered else logger.warning
                log_level(
                    f"Position concentration alert for account {api_key.id}: "
                    f"Largest={largest_pct:.2f}%, Top3={top3_pct:.2f}%, HHI={hhi:.2f}"
                )

    async def check_daily_report(self):
        """ÏùºÏùº Î¶¨Ïä§ÌÅ¨ Î¶¨Ìè¨Ìä∏ Ï†ÑÏÜ° Ï≤¥ÌÅ¨"""

        now = datetime.utcnow()
        current_time = now.time()
        current_date = now.date()

        # Ïù¥ÎØ∏ Ïò§Îäò Î≥¥ÎÉàÏúºÎ©¥ Ïä§ÌÇµ
        if self.last_daily_report_date == current_date:
            return

        # Î¶¨Ìè¨Ìä∏ Ï†ÑÏÜ° ÏãúÍ∞Ñ Ï≤¥ÌÅ¨ (¬±5Î∂Ñ)
        report_time = self.config.DAILY_REPORT_TIME
        time_diff = abs(
            (current_time.hour * 60 + current_time.minute) -
            (report_time.hour * 60 + report_time.minute)
        )

        if time_diff <= 5:  # 5Î∂Ñ Ïù¥ÎÇ¥
            await self.send_daily_reports()
            self.last_daily_report_date = current_date

    async def send_daily_reports(self):
        """Î™®Îì† Í≥ÑÏ†ïÏóê ÏùºÏùº Î¶¨Ìè¨Ìä∏ Ï†ÑÏÜ°"""

        db: Session = next(get_db())

        try:
            active_keys = db.query(ApiKey).filter(
                ApiKey.is_active == True
            ).all()

            for api_key in active_keys:
                try:
                    await self.send_account_daily_report(api_key, db)
                except Exception as e:
                    logger.error(f"Error sending daily report for {api_key.id}: {e}")

        finally:
            db.close()

    async def send_account_daily_report(self, api_key: ApiKey, db: Session):
        """Í∞úÎ≥Ñ Í≥ÑÏ†ï ÏùºÏùº Î¶¨Ìè¨Ìä∏"""

        # Í±∞ÎûòÏÜå ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏÉùÏÑ±
        if api_key.exchange == "binance":
            client = BinanceClient(
                api_key=api_key.api_key,
                api_secret=api_key.api_secret,
                testnet=api_key.testnet
            )
        elif api_key.exchange == "okx":
            client = OKXClient(
                api_key=api_key.api_key,
                api_secret=api_key.api_secret,
                passphrase=api_key.passphrase,
                testnet=api_key.testnet
            )
        else:
            return

        # ÌÖîÎ†àÍ∑∏Îû® Ï±ÑÌåÖ ID
        chat_id = getattr(api_key.user, 'telegram_chat_id', None)
        if not chat_id:
            return

        try:
            # Í≥ÑÏ†ï Ï†ïÎ≥¥ Ï°∞Ìöå
            balance_info = await client.get_account_balance()
            positions = await client.get_positions()

            total_balance = float(balance_info.get('totalWalletBalance', 0))
            unrealized_profit = float(balance_info.get('totalUnrealizedProfit', 0))

            # ÌôúÏÑ± Ìè¨ÏßÄÏÖò
            active_positions = [p for p in positions if float(p.get('positionAmt', 0)) != 0]

            # ÏàòÏùµ/ÏÜêÏã§ Ìè¨ÏßÄÏÖò Ïπ¥Ïö¥Ìä∏
            winning_positions = sum(
                1 for p in active_positions
                if float(p.get('unRealizedProfit', 0)) > 0
            )
            losing_positions = len(active_positions) - winning_positions

            # Ï¥ù ÎÖ∏Ï∂ú
            total_exposure = sum(
                abs(float(p.get('notional', 0)))
                for p in active_positions
            )

            # VaR Ï∂îÏ†ï
            var_amount = total_exposure * 0.05
            var_percentage = (var_amount / total_balance * 100) if total_balance > 0 else 0

            # ÏµúÎåÄ ÎÇôÌè≠ (Í∞ÑÎã®Ìûà ÌòÑÏû¨ ÏÜêÏã§Î°ú Ï∂îÏ†ï)
            max_drawdown_pct = abs(unrealized_profit / total_balance * 100) if unrealized_profit < 0 else 0

            # ÏùºÏùº ÏÜêÏùµ (Í∞ÑÎã®Ìûà ÎØ∏Ïã§ÌòÑ ÏÜêÏùµÏúºÎ°ú Ï∂îÏ†ï)
            daily_pnl = unrealized_profit
            daily_pnl_pct = (daily_pnl / total_balance * 100) if total_balance > 0 else 0

            # Î¶¨Ìè¨Ìä∏ Ï†ÑÏÜ°
            self.telegram.send_daily_risk_report(
                chat_id=chat_id,
                portfolio_value=total_balance,
                total_exposure=total_exposure,
                var_amount=var_amount,
                var_percentage=var_percentage,
                max_drawdown_pct=max_drawdown_pct,
                total_positions=len(active_positions),
                winning_positions=winning_positions,
                losing_positions=losing_positions,
                daily_pnl=daily_pnl,
                daily_pnl_pct=daily_pnl_pct
            )

            logger.info(f"Daily report sent for account {api_key.id}")

        except Exception as e:
            logger.error(f"Error generating daily report for {api_key.id}: {e}")

    def _should_send_alert(self, alert_key: str) -> bool:
        """ÏïåÎ¶º Ï†ÑÏÜ° Ïó¨Î∂Ä Ï≤¥ÌÅ¨ (Ï§ëÎ≥µ Î∞©ÏßÄ)"""

        if alert_key not in self.last_alerts:
            return True

        last_sent = self.last_alerts[alert_key]
        minutes_since = (datetime.utcnow() - last_sent).total_seconds() / 60

        return minutes_since >= self.config.ALERT_COOLDOWN_MINUTES

    def _mark_alert_sent(self, alert_key: str):
        """ÏïåÎ¶º Ï†ÑÏÜ° Í∏∞Î°ù"""
        self.last_alerts[alert_key] = datetime.utcnow()


# Ï†ÑÏó≠ Ïù∏Ïä§ÌÑ¥Ïä§
_risk_monitor_instance: Optional[RiskMonitor] = None


async def start_risk_monitor():
    """Î¶¨Ïä§ÌÅ¨ Î™®ÎãàÌÑ∞ ÏãúÏûë (Ïã±Í∏ÄÌÜ§)"""
    global _risk_monitor_instance

    if _risk_monitor_instance is None:
        _risk_monitor_instance = RiskMonitor()

    await _risk_monitor_instance.start()


async def stop_risk_monitor():
    """Î¶¨Ïä§ÌÅ¨ Î™®ÎãàÌÑ∞ Ï§ëÏßÄ"""
    global _risk_monitor_instance

    if _risk_monitor_instance is not None:
        await _risk_monitor_instance.stop()


def get_risk_monitor() -> Optional[RiskMonitor]:
    """ÌòÑÏû¨ Î¶¨Ïä§ÌÅ¨ Î™®ÎãàÌÑ∞ Ïù∏Ïä§ÌÑ¥Ïä§ Î∞òÌôò"""
    return _risk_monitor_instance
